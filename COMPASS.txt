#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <linux/i2c-dev.h>
#include <iostream>
#include <cmath>

using namespace std;

const int HMC5883L_I2C_ADDR = 0x1E;

int maps(int x, int in_min, int in_max, int out_min, int out_max)
{
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}


void selectDevice(int fd, int addr)
{
    if (ioctl(fd, I2C_SLAVE, addr) < 0)
    {
       cout<<"HMC5883L not present"<<endl;
    }
}

void writeToDevice(int fd, int reg, int value)
{
    char buf[2];
    buf[0]=reg;
    buf[1]=value;

    if (write(fd, buf, 2) != 2)
    {
       cout<<"Can't write to ADXL345\n";
    }
}

int compass_setup(){
    int fd;
    if ((fd = open("/dev/i2c-1", O_RDWR)) < 0)
    {
        //Open port for reading and writing
        cout<<"Failed to open i2c bus\n";
        return 1;
    }
    /* initialise ADXL345 */
    selectDevice(fd, HMC5883L_I2C_ADDR);
    writeToDevice(fd, 0x01, 32);
    writeToDevice(fd, 0x02, 0);
    return fd;
}

float compass(unsigned char buf[], int fd){

        buf[0] = 0x03;
        if ((write(fd, buf, 1)) != 1)
        {
            // Send the register to read from
           cout<<"Error writing to i2c slave\n";
        }

        if (read(fd, buf, 6) != 6) {
           cout<<"Unable to read from HMC5883L\n";
        } else {
            short x = (buf[0] << 8) | buf[1];
            short y = (buf[4] << 8) | buf[5];
            short z = (buf[2] << 8) | buf[3];

            float angle = atan2(y, x) * 180 / M_PI;
                  angle += 80;
            if(angle>360) angle-=360;
            if(angle<0) angle+=360;

            angle=maps(angle,0,360,360,0);
            cout<<angle<<endl;
            return angle;
        }
}

int main(){
    int compass_fd = compass_setup();
    unsigned char buff[16];
    //while(1)
    float angle = compass(buff,compass_fd);
    for(i=0; i<8; i+=2)
    {
      //destination=latlonc[i], latlonc[i+1];
      lat=Serial();
      lon=Serial();
      while(!(latlonc[i]==lat && latlongc[i+1]==lon))
      {
        lat=Serial();
        lon=Serial();
        b=bear(latlonc[i], latlonc[i+1], lat, lon);
        if(b!=angle)
          rotate(b, angle);
      }
    }

    /*********************************************************
     *  receive current lat, long from arduino               *
     *  la1=current latitude; lo1=current longitude          *
     *  la2=loc1(2,3,4) latitude, lo2=loc1(2,3,4) longitude  *
     *********************************************************/
 
//Bearing calculation:
int bear(double dla, double dli, double lati, double longi)
{
 int i=0;
   la1=lati;
   lo1=longi;
   la2=dla;
   lo2=dlo;
   double y = sin(lo2-lo1) * cos(la2);
   double x = (cos(la1)*sin(la2)) - (cos(la1)*sin(la2)*cos(lo2-lo1));
   double bearing = atan2(y, x);
   bearing *= (180/3.141);
   if(bearing<0)
     b=360-bearing;
   else
     b=bearing;
   h=angle;
   float angle = compass(buff,compass_fd);
   return bear;
}
void rotate(int b, int h)
{
   float angle = compass(buff,compass_fd);
   while(angle!=h)
   {
     float angle = compass(buff,compass_fd);
     h=angle;
     int n=h-b;
     if(n>0)
     {
       m=360-n;
       if(m>n)
         cout<<"a";
       else
         cout<<"d";
     }
     else
     {
       m=360+n;
       if(-n>m)
         cout<<"a";
       else
         cout<<"d";
     }
   };
}